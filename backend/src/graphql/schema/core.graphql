enum SourceType { dropbox google_drive onedrive local }

type Source {
  id: ID!
  orgId: ID!
  name: String!
  type: SourceType!
  config: JSON
  active: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FileMeta {
  id: ID!
  orgId: ID!
  sourceId: ID!
  path: String!
  name: String!
  extension: String
  mimeType: String
  size: Int
  createdAt: DateTime!
  updatedAt: DateTime!
  modifiedAt: String
  deletedAt: String
  versionId: String
  metadata: JSON
  classificationStatus: String!
  extractedText: String
}

type FileStats {
  total: Int!
  byStatus: JSON!
  byMimeType: JSON!
}

input FileFilter {
  orgId: ID
  sourceId: ID
  classificationStatus: String
  mimeType: String
  path: String
  name: String
}

type Query {
  getSources(orgId: ID!): [Source!]!
  getSource(sourceId: ID!, orgId: ID!): Source
  getFiles(orgId: ID!, sourceId: ID, limit: Int): [FileMeta!]!
  files(filter: FileFilter, limit: Int, offset: Int): [FileMeta!]!
  getFile(fileId: ID!, orgId: ID!): FileMeta
  getFileStats(orgId: ID!): FileStats!
  getSourceStats(sourceId: ID!, orgId: ID!): JSON!
  budgetVsActualAnalysis(projectId: ID!, orgId: ID!): [BudgetVsActualRow!]!
  vendorPerformanceAnalysis(orgId: ID!): [VendorPerformanceRow!]!
}

type BudgetVsActualRow {
  department: String
  budgeted: Float
  actual: Float
  variance: Float
}

type VendorPerformanceRow {
  vendor_name: String
  category: String
  rating: Float
  total_pos: Int
  total_po_amount: Float
  total_invoices: Int
  total_invoice_amount: Float
  avg_delivery_days: Float
  delivery_performance: String
}

type Mutation {
  createSource(orgId: ID!, name: String!, type: SourceType!, config: JSON): Source!
  updateSourceConfig(sourceId: ID!, orgId: ID!, config: JSON!): Boolean!
  updateSourceStatus(sourceId: ID!, orgId: ID!, active: Boolean!): Boolean!
  deleteSource(sourceId: ID!, orgId: ID!): Boolean!
  triggerSourceResync(sourceId: ID!, orgId: ID!): Boolean!
  reprocessFile(fileId: ID!, orgId: ID!): Boolean!
}

# ===== CLUSTER-CENTRIC EXTENSIONS =====
# Integrated from enhanced.graphql - cluster-centric knowledge representation

scalar DateTime
scalar JSON
scalar Upload

type Vendor {
  id: ID!
  orgId: String!
  name: String!
  category: String
  contact_name: String
  contact_email: String
  contact_phone: String
  address: String
  tax_id: String
  payment_terms: String
  preferred_payment_method: String
  status: String! # active | inactive | suspended
  rating: Float
  metadata: JSON
  created_at: DateTime
  updated_at: DateTime
}

# Additional enums for cluster processing
enum ClassificationStatus {
  PENDING
  CLASSIFIED
  MANUAL_REVIEW
  FAILED
}

enum CommitStatus {
  PENDING
  COMMITTED
  FAILED
}

enum ActionStatus {
  SUCCESS
  FAILED
  PENDING
}

enum ProjectStatus {
  DEVELOPMENT
  ACTIVE
  COMPLETED
  ARCHIVED
  CANCELLED
}

input TalentInput {
  orgId: ID!
  name: String!
  agent_contact: String
  union_status: String
  rate_amount: Float
  status: String!
  metadata: JSON
}

input CommitFilter {
  orgId: ID
  projectId: ID
  branchName: String
  author: String
  authorType: String
  createdAfter: DateTime
  createdBefore: DateTime
}

# ===== CONTENT CLUSTER SYSTEM =====

# ContentCluster represents a cluster of extracted content nodes from a file
type ContentCluster {
  id: ID!
  orgId: ID!
  fileId: ID!
  projectId: ID
  status: String!
  extractionMethod: String
  parserName: String
  parserVersion: String
  confidence: Float
  entitiesCount: Int!
  linksCount: Int!
  extractedAt: DateTime
  promotedAt: DateTime
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Relationships
  file: FileMeta!
  entities: [Content!]!
  extractionJobs: [ExtractionJob!]!
}

# ExtractionJob tracks the staging and promotion of content extraction
type ExtractionJob {
  id: ID!
  orgId: ID!
  fileId: ID!
  clusterId: ID
  status: String!
  parserName: String!
  parserVersion: String!
  method: String!
  confidence: Float
  dedupeKey: String!
  createdAt: DateTime!
  completedAt: DateTime
  promotedAt: DateTime
  metadata: JSON
  
  # Relationships
  file: FileMeta!
  cluster: ContentCluster
  stagedEntities: [StagedEntity!]!
  stagedLinks: [StagedLink!]!
  promotionAudits: [PromotionAudit!]!
}

# StagedEntity represents extracted entities before promotion to the graph
type StagedEntity {
  id: ID!
  jobId: ID!
  kind: String!
  rawJson: JSON!
  hash: String!
  confidence: Float!
  sourceOffset: String
  createdAt: DateTime!
  
  # Relationships
  job: ExtractionJob!
}

# StagedLink represents extracted relationships before promotion to the graph
type StagedLink {
  id: ID!
  jobId: ID!
  fromHash: String!
  toHash: String!
  relType: String!
  rawJson: JSON!
  confidence: Float!
  createdAt: DateTime!
  
  # Relationships
  job: ExtractionJob!
}

# PromotionAudit tracks all promotion and rollback operations
type PromotionAudit {
  id: ID!
  jobId: ID!
  actor: String!
  action: String!
  beforeJson: JSON
  afterJson: JSON
  timestamp: DateTime!
  
  # Relationships
  job: ExtractionJob!
}

# ParserRegistry configures which parsers are enabled for different file types
type ParserRegistry {
  id: ID!
  orgId: ID!
  slot: String!
  mimeType: String
  extension: String
  parserName: String!
  parserVersion: String!
  minConfidence: Float!
  featureFlag: Boolean!
  enabled: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input SaveParserConfigInput {
  id: ID
  slot: String!
  mimeType: String
  extension: String
  parserName: String!
  parserVersion: String!
  minConfidence: Float!
  featureFlag: Boolean!
  enabled: Boolean!
}

# ===== CROSS-LAYER ONTOLOGY ENTITIES =====

# Content entities (generic content type)
type Content {
  id: ID!
  type: String!
  properties: JSON!
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
}

# Scene entity (Idea layer)
type Scene {
  id: ID!
  orgId: String!
  project_id: String!
  number: String!
  title: String!
  location: String
  time_of_day: String
  page_count: Float
  status: String!
  description: String
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Cross-layer relationships
  scheduledOn: ShootDay # Scene -> ShootDay (Idea to IRL)
  hasLocation: Location # Scene -> Location
  budgetedBy: [Budget!]! # Scene -> Budget (Idea to Ops)
  purchaseOrders: [PurchaseOrder!]! # Scene -> PurchaseOrder (Idea to Ops)
  characters: [Character!]! # Scene -> Character
}

# Character entity (Idea layer)
type Character {
  id: ID!
  orgId: String!
  project_id: String!
  name: String!
  role_type: String!
  description: String
  age_range: String
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Cross-layer relationships
  portrayedBy: Talent # Character -> Talent (Idea to IRL)
  scenes: [Scene!]! # Character -> Scene
  castingStatus: String # uncast, cast, callback, etc.
}

# Talent entity (IRL layer)
type Talent {
  id: ID!
  orgId: ID!
  name: String!
  agent_contact: String
  union_status: String
  rate_amount: Float
  status: String!
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Cross-layer relationships
  characters: [Character!]! # Talent -> Character (IRL to Idea)
  shootDays: [ShootDay!]! # Talent -> ShootDay
  purchaseOrders: [PurchaseOrder!]! # Talent -> PurchaseOrder (IRL to Ops)
}

# Crew entity (IRL layer)
type Crew {
  id: ID!
  orgId: ID!
  name: String!
  role: String!
  department: String!
  rate_amount: Float
  status: String!
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Cross-layer relationships
  shootDays: [ShootDay!]! # Crew -> ShootDay
  purchaseOrders: [PurchaseOrder!]! # Crew -> PurchaseOrder (IRL to Ops)
}

input CrewInput {
  orgId: ID!
  name: String!
  role: String!
  department: String!
  rate_amount: Float
  status: String!
  metadata: JSON
}

# Invoice entity (Ops layer)
type Invoice {
  id: ID!
  orgId: ID!
  vendor_id: ID!
  project_id: ID
  invoice_number: String!
  description: String
  total_amount: Float!
  amount: Float
  currency: String
  tax_amount: Float
  po_id: ID
  invoice_date: DateTime!
  due_date: DateTime!
  status: String!
  payment_date: DateTime
  payment_method: String
  approved_by: String
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Cross-layer relationships
  vendor: Vendor # Invoice -> Vendor
  project: Project # Invoice -> Project (Ops to Creative)
  purchaseOrder: PurchaseOrder # Invoice -> PurchaseOrder
}

input InvoiceInput {
  orgId: ID!
  vendor_id: ID!
  project_id: ID
  invoice_number: String!
  description: String
  total_amount: Float!
  amount: Float
  currency: String
  tax_amount: Float
  po_id: ID
  invoice_date: DateTime!
  due_date: DateTime!
  status: String!
  payment_date: DateTime
  payment_method: String
  approved_by: String
  metadata: JSON
}

# ComplianceRule entity (Ops layer)
type ComplianceRule {
  id: ID!
  orgId: ID!
  name: String!
  category: String!
  description: String!
  jurisdiction: String
  authority: String
  severity: String!
  effective_date: DateTime!
  expiry_date: DateTime
  status: String!
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ComplianceRuleInput {
  orgId: ID!
  name: String!
  category: String!
  description: String!
  jurisdiction: String
  authority: String
  severity: String!
  effective_date: DateTime!
  expiry_date: DateTime
  status: String!
  metadata: JSON
}

# ShootDay entity (IRL layer)
type ShootDay {
  id: ID!
  orgId: String!
  project_id: String!
  date: DateTime!
  call_time: String
  wrap_time: String
  location_id: String
  status: String!
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Cross-layer relationships
  scenes: [Scene!]! # ShootDay -> Scene (IRL to Idea)
  talent: [Talent!]! # ShootDay -> Talent
  crew: [Crew!]! # ShootDay -> Crew
  location: Location # ShootDay -> Location
}

# Location entity (IRL layer)
type Location {
  id: ID!
  orgId: String!
  name: String!
  address: String
  type: String!
  capacity: Int
  rate_amount: Float
  status: String!
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Cross-layer relationships
  scenes: [Scene!]! # Location -> Scene (IRL to Idea)
  shootDays: [ShootDay!]! # Location -> ShootDay
}

# Budget entity (Ops layer)
type Budget {
  id: ID!
  orgId: String!
  project_id: String!
  category: String!
  line_item: String!
  budgeted_amount: Float!
  actual_amount: Float
  currency: String!
  vendor_id: String
  shoot_day_id: String
  scene_id: String
  character_id: String
  purchase_order_id: String
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Cross-layer relationships
  scenes: [Scene!]! # Budget -> Scene (Ops to Idea)
  purchaseOrders: [PurchaseOrder!]! # Budget -> PurchaseOrder
}

# PurchaseOrder entity (Ops layer)
type PurchaseOrder {
  id: ID!
  orgId: ID!
  project_id: String!
  vendor: String!
  po_number: String!
  amount: Float!
  status: String!
  description: String
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Cross-layer relationships
  scenes: [Scene!]! # PurchaseOrder -> Scene (Ops to Idea)
  talent: [Talent!]! # PurchaseOrder -> Talent (Ops to IRL)
  crew: [Crew!]! # PurchaseOrder -> Crew (Ops to IRL)
  budget: Budget # PurchaseOrder -> Budget
}

# Organization entity (updated with cluster support)
type Organization {
  id: ID!
  name: String!
  slug: String!
  settings: JSON
  projects: [Project!]!
  sources: [Source!]!
  users: [User!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

# Entity version type for provenance tracking
type EntityVersion {
  id: ID!
  entityId: ID!
  entityType: String!
  version: Int!
  data: JSON!
  timestamp: DateTime!
  userId: ID
  operation: String!
  metadata: JSON
}

# Project entity (updated with cluster support)
type Project {
  id: ID!
  orgId: ID!
  name: String!
  status: ProjectStatus!
  settings: JSON
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Cluster-centric relationships
  contentClusters: [ContentCluster!]!
  scenes: [Scene!]!
  characters: [Character!]!
  shootDays: [ShootDay!]!
  budgets: [Budget!]!
}

# User entity
type User {
  id: ID!
  orgId: ID!
  email: String!
  name: String!
  role: String!
  permissions: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

# ===== EXTENDED QUERIES AND MUTATIONS =====

extend type Query {
  # Project queries
  project(id: ID!, orgId: ID!): Project
  projects(orgId: ID!): [Project!]!
  
  # Scene and breakdown queries
  sceneBreakdown(shootDayDate: DateTime!, orgId: ID!): JSON
  
  # Provenance and versioning queries
  entityHistory(entityId: ID!, entityType: String!, orgId: ID!): [EntityVersion!]!
  entityAtTime(entityId: ID!, timestamp: DateTime!, orgId: ID!): EntityVersion
  
  # Cluster-centric queries
  getContentCluster(clusterId: ID!, orgId: ID!): ContentCluster
  getContentClusters(orgId: ID!, fileId: ID, projectId: ID): [ContentCluster!]!
  getExtractionJob(jobId: ID!, orgId: ID!): ExtractionJob
  getExtractionJobs(orgId: ID!, status: String): [ExtractionJob!]!
  
  # Cross-layer entity queries
  getScenes(orgId: ID!, projectId: ID): [Scene!]!
  getCharacters(orgId: ID!, projectId: ID): [Character!]!
  getTalent(orgId: ID!): [Talent!]!
  getCrew(orgId: ID!): [Crew!]!
  getShootDays(orgId: ID!, projectId: ID): [ShootDay!]!
  getLocations(orgId: ID!): [Location!]!
  getBudgets(orgId: ID!, projectId: ID): [Budget!]!
  getPurchaseOrders(orgId: ID!, projectId: ID): [PurchaseOrder!]!
  
  # Cross-layer validation queries
  validateCrossLayerLinks(orgId: ID!): JSON!
  getCrossLayerStatistics(orgId: ID!): JSON!

  # Provenance & Versioning
  commit(id: ID!, orgId: ID!): Commit
  commits(filter: CommitFilter, limit: Int = 50, offset: Int = 0): [Commit!]!
  commitHistory(orgId: ID!, branchName: String!, limit: Int = 50): [Commit!]!
  entityVersions(orgId: ID!, entityId: ID!, entityType: String!): [Version!]!
  branches(orgId: ID!): [Branch!]!
}

extend type Mutation {
  # Cluster processing mutations
  triggerClusterExtraction(fileId: ID!, orgId: ID!, parserName: String): ExtractionJob!
  promoteExtractionJob(jobId: ID!, orgId: ID!): Boolean!
  rollbackExtractionJob(jobId: ID!, orgId: ID!): Boolean!
  
  # Cross-layer link mutations
  createCrossLayerLink(orgId: ID!, fromEntityId: ID!, toEntityId: ID!, relationshipType: String!): Boolean!
  validateAndRepairLinks(orgId: ID!): JSON!

  # Content entity mutations
  createTalent(input: TalentInput!, userId: ID!): Talent!
  createCrew(input: CrewInput!, userId: ID!): Crew!
  createInvoice(input: InvoiceInput!, userId: ID!): Invoice!
  createComplianceRule(input: ComplianceRuleInput!, userId: ID!): ComplianceRule!

  # Provenance operations
  createBranch(name: String!, orgId: ID!, projectId: ID, description: String!, userId: ID!, fromCommit: String): Branch!
  createEdgeFact(type: String!, fromId: ID!, toId: ID!, orgId: ID!, userId: ID!, props: JSON, fromType: String, toType: String): JSON!
  endEdgeFact(edgeFactId: ID!, orgId: ID!, userId: ID!): JSON!
  
  # Cross-layer linking
  linkSceneToCharacter(sceneId: ID!, characterId: ID!, orgId: ID!, userId: String!): LinkResult!
  linkEntityToScene(entityId: ID!, entityType: String!, sceneId: ID!, orgId: ID!, userId: String!): LinkResult!
  
  # Parser configuration mutations
  saveParserConfig(orgId: ID!, input: SaveParserConfigInput!): ParserRegistry!
  enableParser(orgId: ID!, id: ID!): ParserRegistry!
  disableParser(orgId: ID!, id: ID!): ParserRegistry!
}

type LinkResult { success: Boolean! }

# ===== VERSIONING & PROVENANCE TYPES =====

type Commit {
  id: ID!
  orgId: ID!
  message: String!
  author: String!
  authorType: String!
  parentCommitId: ID
  branchName: String!
  signature: String
  status: CommitStatus
  createdAt: DateTime!
  metadata: JSON
}

type Action {
  id: ID!
  commitId: ID!
  actionType: String!
  tool: String!
  entityType: String!
  entityId: String!
  inputs: JSON
  outputs: JSON
  status: ActionStatus!
  errorMessage: String
  createdAt: DateTime!
}

type Version {
  id: ID!
  orgId: ID!
  entityId: String!
  entityType: String!
  properties: JSON!
  commitId: ID!
  createdAt: DateTime!
  contentHash: String
  metadata: JSON
}

type Branch {
  name: String!
  orgId: String!
  project_id: String
  description: String!
  created_from_commit: String
  head_commit: String
  status: String!
  created_by: String!
  created_at: DateTime!
  merged_at: DateTime
  merged_by: String
  metadata: JSON
}
