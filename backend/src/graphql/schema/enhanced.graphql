# Enhanced GraphQL Schema for Olivine V11
# Based on Implementation Plan 05-API-Implementation.md

scalar DateTime
scalar JSON
scalar Upload

# ===== ENUMS =====
enum ProjectStatus {
  ACTIVE
  COMPLETED
  ARCHIVED
  CANCELLED
}

enum ClassificationStatus {
  PENDING
  CLASSIFIED
  MANUAL_REVIEW
  FAILED
}

enum SourceType {
  dropbox
  google_drive
  supabase
  local
}

enum CommitStatus {
  PENDING
  COMMITTED
  FAILED
}

enum ActionStatus {
  SUCCESS
  FAILED
  PENDING
}

# ===== CORE ENTITIES =====

type Organization {
  id: ID!
  name: String!
  slug: String!
  settings: JSON
  projects: [Project!]!
  sources: [Source!]!
  users: [User!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

# ===== TAXONOMY SYSTEM =====

type CanonicalSlot {
  key: String!
  org_id: String!
  description: String!
  category: String!
  required: Boolean!
  multiple: Boolean!
  validation_rules: JSON!
}

type TaxonomyProfile {
  id: ID!
  org_id: String!
  name: String!
  description: String!
  active: Boolean!
  priority: Int!
  metadata: JSON
  createdAt: DateTime!
  rules: [TaxonomyRule!]!
}

type TaxonomyRule {
  id: ID!
  org_id: String!
  match_pattern: String!
  slot_key: String!
  file_type: String
  path_pattern: String
  priority: Int!
  enabled: Boolean!
  confidence: Float!
  conditions: JSON!
}

type Classification {
  slot: String!
  confidence: Float!
  method: String!
  rule_id: String
  metadata: JSON
}

# ===== CONTENT ONTOLOGY =====

type Scene {
  id: ID!
  org_id: String!
  project_id: String!
  number: String!
  title: String!
  location: String
  time_of_day: String
  page_count: Float
  status: String!
  description: String
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Character {
  id: ID!
  org_id: String!
  project_id: String!
  name: String!
  role_type: String!
  description: String
  age_range: String
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Talent {
  id: ID!
  org_id: String!
  name: String!
  agent_contact: String
  union_status: String
  rate_amount: Float
  status: String!
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Crew {
  id: ID!
  org_id: String!
  name: String!
  role: String!
  department: String!
  rate_amount: Float
  status: String!
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ShootDay {
  id: ID!
  org_id: String!
  project_id: String!
  date: DateTime!
  call_time: String
  wrap_time: String
  location_id: String
  status: String!
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
}

# ===== OPERATIONS ONTOLOGY =====

type Vendor {
  id: ID!
  org_id: String!
  name: String!
  category: String!
  contact_name: String
  contact_email: String
  contact_phone: String
  address: String
  tax_id: String
  payment_terms: String
  preferred_payment_method: String
  status: String!
  rating: Float
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PurchaseOrder {
  id: ID!
  org_id: String!
  project_id: String!
  po_number: String!
  vendor_id: String!
  scene_id: String
  crew_role: String
  description: String!
  amount: Float!
  currency: String!
  status: String!
  order_date: DateTime!
  needed_date: DateTime
  delivery_address: String
  approved_by: String
  created_by: String!
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Invoice {
  id: ID!
  org_id: String!
  project_id: String!
  vendor_id: String!
  po_id: String
  invoice_number: String!
  amount: Float!
  currency: String!
  tax_amount: Float
  total_amount: Float!
  invoice_date: DateTime!
  due_date: DateTime!
  status: String!
  payment_date: DateTime
  payment_method: String
  approved_by: String
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Budget {
  id: ID!
  org_id: String!
  project_id: String!
  name: String!
  total_budget: Float!
  currency: String!
  status: String!
  version: String!
  approved_by: String
  approved_date: DateTime
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ComplianceRule {
  id: ID!
  org_id: String!
  name: String!
  category: String!
  description: String!
  jurisdiction: String
  authority: String
  severity: String!
  effective_date: DateTime!
  expiry_date: DateTime
  status: String!
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
}

# ===== PROVENANCE SYSTEM =====

type EntityVersion {
  id: ID!
  entity_id: String!
  entity_type: String!
  props: JSON!
  valid_from: DateTime!
  valid_to: DateTime
  tx_time: DateTime!
  created_by_commit: String!
  org_id: String!
  metadata: JSON
}

type EdgeFact {
  id: ID!
  type: String!
  from_id: String!
  to_id: String!
  from_type: String
  to_type: String
  valid_from: DateTime!
  valid_to: DateTime
  created_by_commit: String!
  ended_by_commit: String
  org_id: String!
  props: JSON
  metadata: JSON
}

type Branch {
  name: String!
  org_id: String!
  project_id: String
  description: String!
  created_from_commit: String
  head_commit: String
  status: String!
  created_by: String!
  created_at: DateTime!
  merged_at: DateTime
  merged_by: String
  metadata: JSON
}

type Project {
  id: ID!
  orgId: ID!
  name: String!
  description: String
  status: ProjectStatus!
  settings: JSON
  files: [File!]!
  content: [Content!]!
  commits: [Commit!]!
  organization: Organization!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Source {
  id: ID!
  orgId: ID!
  name: String!
  provider: SourceType!
  providerAccountId: String!
  tokenRef: String
  settings: JSON
  status: String!
  files: [File!]!
  organization: Organization!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type User {
  id: ID!
  orgId: ID!
  email: String!
  role: String!
  lastLoginAt: DateTime
  organization: Organization!
  commits: [Commit!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type File {
  id: ID!
  orgId: ID!
  sourceId: ID!
  projectId: ID
  parentId: ID
  path: String!
  name: String!
  size: Int
  mimeType: String
  checksum: String
  metadata: JSON
  classificationStatus: ClassificationStatus!
  classificationConfidence: Float
  canonicalSlot: String
  extractedText: String
  current: Boolean!
  deleted: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  modified: DateTime
  
  # Relationships
  source: Source!
  project: Project
  parent: File
  children: [File!]!
  versions: [Version!]!
  content: [Content!]!
  actions: [Action!]!
}

type Content {
  id: ID!
  orgId: ID!
  contentKey: String!
  contentType: String!
  title: String!
  description: String
  format: String!
  status: String!
  current: Boolean!
  deleted: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  metadata: JSON
  
  # Relationships
  organization: Organization!
  references: [File!]!
  derivedFrom: [Content!]!
  versions: [Version!]!
  actions: [Action!]!
}

# ===== VERSIONING & PROVENANCE =====

type Commit {
  id: ID!
  orgId: ID!
  message: String!
  author: String!
  authorType: String!
  parentCommitId: ID
  branchName: String!
  signature: String!
  status: CommitStatus!
  createdAt: DateTime!
  metadata: JSON
  
  # Relationships
  organization: Organization!
  project: Project
  parent: Commit
  children: [Commit!]!
  actions: [Action!]!
  versions: [Version!]!
}

type Action {
  id: ID!
  commitId: ID!
  actionType: String!
  tool: String!
  entityType: String!
  entityId: String!
  inputs: JSON!
  outputs: JSON!
  status: ActionStatus!
  errorMessage: String
  createdAt: DateTime!
  
  # Relationships
  commit: Commit!
}

type Version {
  id: ID!
  orgId: ID!
  entityId: String!
  entityType: String!
  properties: JSON!
  commitId: ID!
  createdAt: DateTime!
  contentHash: String!
  metadata: JSON
  
  # Relationships
  organization: Organization!
  commit: Commit!
}

# ===== SEARCH & FILTERING =====

input FileFilter {
  orgId: ID
  sourceId: ID
  projectId: ID
  classificationStatus: ClassificationStatus
  mimeType: String
  path: String
  name: String
  sizeMin: Int
  sizeMax: Int
  modifiedAfter: DateTime
  modifiedBefore: DateTime
  createdAfter: DateTime
  createdBefore: DateTime
}

input ContentFilter {
  orgId: ID
  contentType: String
  status: String
  title: String
  createdAfter: DateTime
  createdBefore: DateTime
}

input CommitFilter {
  orgId: ID
  projectId: ID
  branchName: String
  author: String
  authorType: String
  createdAfter: DateTime
  createdBefore: DateTime
}

# ===== SEARCH RESULTS =====

type FileSearchResult {
  file: File!
  score: Float!
  highlights: [String!]!
}

type FileSearchResults {
  results: [FileSearchResult!]!
  totalCount: Int!
  facets: JSON
}

type ContentSearchResult {
  content: Content!
  score: Float!
  highlights: [String!]!
}

type ContentSearchResults {
  results: [ContentSearchResult!]!
  totalCount: Int!
  facets: JSON
}

# ===== STATISTICS =====

type FileStats {
  total: Int!
  byStatus: JSON!
  byMimeType: JSON!
  bySource: JSON!
  byProject: JSON!
}

type ClassificationStats {
  total: Int!
  bySlot: JSON!
  byConfidence: JSON!
  pending: Int!
  failed: Int!
}

type ProvenanceStats {
  commits: Int!
  actions: Int!
  versions: Int!
  branches: [String!]!
}

type SystemHealthStatus {
  status: String!
  services: JSON!
  metrics: JSON!
  timestamp: DateTime!
}

# ===== INPUT TYPES =====

input CreateProjectInput {
  orgId: ID!
  name: String!
  description: String
  settings: JSON
}

input UpdateProjectInput {
  id: ID!
  orgId: ID!
  name: String
  description: String
  status: ProjectStatus
  settings: JSON
}

input CreateSourceInput {
  orgId: ID!
  name: String!
  provider: SourceType!
  providerAccountId: String!
  tokenRef: String
  settings: JSON
}

input UpdateSourceInput {
  id: ID!
  orgId: ID!
  name: String
  settings: JSON
  status: String
}

input CreateContentInput {
  orgId: ID!
  contentKey: String!
  contentType: String!
  title: String!
  description: String
  format: String!
  metadata: JSON
  references: [ID!]  # File or Content IDs to reference
  derivedFrom: [ID!] # Content IDs this is derived from
}

input UpdateContentInput {
  id: ID!
  orgId: ID!
  title: String
  description: String
  format: String
  status: String
  metadata: JSON
}

input ClassifyFileInput {
  fileId: ID!
  orgId: ID!
  canonicalSlot: String!
  confidence: Float
  metadata: JSON
}

input CreateCommitInput {
  orgId: ID!
  projectId: ID
  message: String!
  author: String!
  authorType: String!
  parentCommitId: ID
  branchName: String
  metadata: JSON
}

# ===== QUERIES =====

type Query {
  # Organizations
  organization(id: ID!): Organization
  organizations: [Organization!]!
  
  # Projects
  project(id: ID!, orgId: ID!): Project
  projects(orgId: ID!): [Project!]!
  
  # Sources
  source(id: ID!, orgId: ID!): Source
  sources(orgId: ID!): [Source!]!
  
  # Files
  file(id: ID!, orgId: ID!): File
  files(filter: FileFilter, limit: Int = 50, offset: Int = 0): [File!]!
  
  # Content
  content(id: ID!, orgId: ID!): Content
  contents(filter: ContentFilter, limit: Int = 50, offset: Int = 0): [Content!]!
  
  # Search
  searchFiles(orgId: ID!, query: String!, filters: FileFilter, limit: Int = 20): FileSearchResults!
  searchContent(orgId: ID!, query: String!, filters: ContentFilter, limit: Int = 20): ContentSearchResults!
  
  # Versioning & Provenance
  commit(id: ID!, orgId: ID!): Commit
  commits(filter: CommitFilter, limit: Int = 50, offset: Int = 0): [Commit!]!
  commitHistory(orgId: ID!, branchName: String!, limit: Int = 50): [Commit!]!
  entityVersions(orgId: ID!, entityId: ID!, entityType: String!): [Version!]!
  
  # Taxonomy System
  canonicalSlots(orgId: ID!): [CanonicalSlot!]!
  taxonomyProfiles(orgId: ID!): [TaxonomyProfile!]!
  taxonomyRules(profileId: ID!, orgId: ID!): [TaxonomyRule!]!
  fileClassification(fileId: ID!, orgId: ID!): Classification
  
  # Content Ontology
  sceneBreakdown(shootDayDate: DateTime!, orgId: ID!): [JSON!]!
  
  # Operations
  budgetVsActualAnalysis(projectId: ID!, orgId: ID!): [JSON!]!
  vendorPerformanceAnalysis(orgId: ID!): [JSON!]!
  
  # Provenance
  entityHistory(entityId: ID!, entityType: String!, orgId: ID!): [EntityVersion!]!
  entityAtTime(entityId: ID!, timestamp: DateTime!, orgId: ID!): JSON
  
  # Statistics
  fileStats(orgId: ID!): FileStats!
  classificationStats(orgId: ID!): ClassificationStats!
  provenanceStats(orgId: ID!): ProvenanceStats!
  systemHealth: SystemHealthStatus!
}

# ===== MUTATIONS =====

type Mutation {
  # Projects
  createProject(input: CreateProjectInput!): Project!
  updateProject(input: UpdateProjectInput!): Project!
  deleteProject(id: ID!, orgId: ID!): Boolean!
  
  # Sources
  createSource(input: CreateSourceInput!): Source!
  updateSource(input: UpdateSourceInput!): Source!
  deleteSource(id: ID!, orgId: ID!): Boolean!
  triggerSourceSync(sourceId: ID!, orgId: ID!): Boolean!
  
  # Content
  createContent(input: CreateContentInput!): Content!
  updateContent(input: UpdateContentInput!): Content!
  deleteContent(id: ID!, orgId: ID!): Boolean!
  
  # Classification
  classifyFile(input: ClassifyFileInput!): File!
  triggerFileReprocessing(fileId: ID!, orgId: ID!): Boolean!
  bulkClassifyFiles(fileIds: [ID!]!, orgId: ID!): [File!]!
  
  # Taxonomy System
  createCanonicalSlot(input: JSON!, orgId: ID!): CanonicalSlot!
  createTaxonomyProfile(input: JSON!, orgId: ID!): TaxonomyProfile!
  createTaxonomyRule(input: JSON!, profileId: ID!, orgId: ID!): TaxonomyRule!
  classifyTaxonomyFile(fileId: ID!, orgId: ID!, userId: ID!): Classification
  applyManualClassification(fileId: ID!, slot: String!, confidence: Float, orgId: ID!, userId: ID!): Classification!
  
  # Content Ontology
  createScene(input: JSON!, userId: ID!): Scene!
  createCharacter(input: JSON!, userId: ID!): Character!
  createTalent(input: JSON!, userId: ID!): Talent!
  createCrew(input: JSON!, userId: ID!): Crew!
  linkSceneToCharacter(sceneId: ID!, characterId: ID!, orgId: ID!, userId: ID!): JSON!
  
  # Operations
  createVendor(input: JSON!, userId: ID!): Vendor!
  createPurchaseOrder(input: JSON!, userId: ID!): PurchaseOrder!
  createInvoice(input: JSON!, userId: ID!): Invoice!
  createBudget(input: JSON!, userId: ID!): Budget!
  createComplianceRule(input: JSON!, userId: ID!): ComplianceRule!
  
  # Provenance
  createBranch(name: String!, orgId: ID!, projectId: ID, description: String!, userId: ID!, fromCommit: String): Branch!
  createEdgeFact(type: String!, fromId: ID!, toId: ID!, orgId: ID!, userId: ID!, props: JSON, fromType: String, toType: String): JSON!
  endEdgeFact(edgeFactId: ID!, orgId: ID!, userId: ID!): JSON!
  
  # Commits
  createCommit(input: CreateCommitInput!): Commit!
  
  # System Operations
  triggerFullSync(orgId: ID!): Boolean!
  rebuildIndex(orgId: ID!): Boolean!
}

# ===== SUBSCRIPTIONS =====

type Subscription {
  # File updates
  fileUpdated(orgId: ID!, projectId: ID): File!
  fileClassified(orgId: ID!, projectId: ID): File!
  
  # Content ontology updates
  sceneCreated(orgId: ID!, projectId: ID!): Scene!
  characterCreated(orgId: ID!, projectId: ID!): Character!
  
  # Operations ontology updates
  purchaseOrderCreated(orgId: ID!, projectId: ID): PurchaseOrder!
  budgetUpdated(orgId: ID!, projectId: ID!): Budget!
  
  # Agent processing updates
  agentTaskCompleted(orgId: ID!, agentType: String): JSON!
  workflowExecuted(orgId: ID!, workflowId: String): JSON!
  
  # Novelty detection alerts
  noveltyDetected(orgId: ID!, alertLevel: String): JSON!
  
  # Provenance updates
  commitCreated(orgId: ID!, projectId: ID, branchName: String): Commit!
  entityVersionCreated(orgId: ID!, entityType: String): EntityVersion!
  
  # System health and monitoring
  systemAlert(orgId: ID!, severity: String): JSON!
  
  # Sync progress
  syncProgress(orgId: ID!, sourceId: ID): SyncProgressUpdate!
  
  # Classification updates
  classificationProgress(orgId: ID!): ClassificationProgressUpdate!
  
  # System events
  systemEvents(orgId: ID!): SystemEvent!
}

# ===== SUBSCRIPTION TYPES =====

type SyncProgressUpdate {
  sourceId: ID!
  status: String!
  progress: Float!
  filesProcessed: Int!
  totalFiles: Int!
  currentFile: String
  errors: [String!]!
  estimatedTimeRemaining: Int
}

type ClassificationProgressUpdate {
  status: String!
  progress: Float!
  filesProcessed: Int!
  totalFiles: Int!
  currentFile: File
  stats: ClassificationStats!
}

type SystemEvent {
  type: String!
  message: String!
  data: JSON
  timestamp: DateTime!
  severity: String!
}
