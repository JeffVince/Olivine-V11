enum SourceType { dropbox google_drive onedrive local }

type Source {
  id: ID!
  orgId: ID!
  name: String!
  type: SourceType!
  config: JSON
  active: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FileMeta {
  id: ID!
  orgId: ID!
  sourceId: ID!
  path: String!
  name: String!
  extension: String
  mimeType: String
  size: Int
  createdAt: DateTime!
  updatedAt: DateTime!
  modifiedAt: String
  deletedAt: String
  versionId: String
  metadata: JSON
  classificationStatus: String!
  extractedText: String
}

type FileStats {
  total: Int!
  byStatus: JSON!
  byMimeType: JSON!
}

type Query {
  getSources(orgId: ID!): [Source!]!
  getSource(sourceId: ID!, orgId: ID!): Source
  getFiles(orgId: ID!, sourceId: ID, limit: Int): [FileMeta!]!
  getFile(fileId: ID!, orgId: ID!): FileMeta
  getFileStats(orgId: ID!): FileStats!
  getSourceStats(sourceId: ID!, orgId: ID!): JSON!
  budgetVsActualAnalysis(projectId: ID!, orgId: ID!): [BudgetVsActualRow!]!
  vendorPerformanceAnalysis(orgId: ID!): [VendorPerformanceRow!]!
}

type BudgetVsActualRow {
  department: String
  budgeted: Float
  actual: Float
  variance: Float
}

type VendorPerformanceRow {
  vendor_name: String
  category: String
  rating: Float
  total_pos: Int
  total_po_amount: Float
  total_invoices: Int
  total_invoice_amount: Float
  avg_delivery_days: Float
  delivery_performance: String
}

type Mutation {
  createSource(orgId: ID!, name: String!, type: SourceType!, config: JSON): Source!
  updateSourceConfig(sourceId: ID!, orgId: ID!, config: JSON!): Boolean!
  updateSourceStatus(sourceId: ID!, orgId: ID!, active: Boolean!): Boolean!
  deleteSource(sourceId: ID!, orgId: ID!): Boolean!
  triggerSourceResync(sourceId: ID!, orgId: ID!): Boolean!
  reprocessFile(fileId: ID!, orgId: ID!): Boolean!
}

# ===== CLUSTER-CENTRIC EXTENSIONS =====
# Integrated from enhanced.graphql - cluster-centric knowledge representation

scalar DateTime
scalar JSON
scalar Upload

# Additional enums for cluster processing
enum ClassificationStatus {
  PENDING
  CLASSIFIED
  MANUAL_REVIEW
  FAILED
}

enum CommitStatus {
  PENDING
  COMMITTED
  FAILED
}

enum ActionStatus {
  SUCCESS
  FAILED
  PENDING
}

enum ProjectStatus {
  DEVELOPMENT
  ACTIVE
  COMPLETED
  ARCHIVED
  CANCELLED
}

# ===== CONTENT CLUSTER SYSTEM =====

# ContentCluster represents a cluster of extracted content nodes from a file
type ContentCluster {
  id: ID!
  orgId: ID!
  fileId: ID!
  projectId: ID
  status: String!
  extractionMethod: String
  parserName: String
  parserVersion: String
  confidence: Float
  entitiesCount: Int!
  linksCount: Int!
  extractedAt: DateTime
  promotedAt: DateTime
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Relationships
  file: FileMeta!
  entities: [Content!]!
  extractionJobs: [ExtractionJob!]!
}

# ExtractionJob tracks the staging and promotion of content extraction
type ExtractionJob {
  id: ID!
  orgId: ID!
  fileId: ID!
  clusterId: ID
  status: String!
  parserName: String!
  parserVersion: String!
  method: String!
  confidence: Float
  dedupeKey: String!
  createdAt: DateTime!
  completedAt: DateTime
  promotedAt: DateTime
  metadata: JSON
  
  # Relationships
  file: FileMeta!
  cluster: ContentCluster
  stagedEntities: [StagedEntity!]!
  stagedLinks: [StagedLink!]!
  promotionAudits: [PromotionAudit!]!
}

# StagedEntity represents extracted entities before promotion to the graph
type StagedEntity {
  id: ID!
  jobId: ID!
  kind: String!
  rawJson: JSON!
  hash: String!
  confidence: Float!
  sourceOffset: String
  createdAt: DateTime!
  
  # Relationships
  job: ExtractionJob!
}

# StagedLink represents extracted relationships before promotion to the graph
type StagedLink {
  id: ID!
  jobId: ID!
  fromHash: String!
  toHash: String!
  relType: String!
  rawJson: JSON!
  confidence: Float!
  createdAt: DateTime!
  
  # Relationships
  job: ExtractionJob!
}

# PromotionAudit tracks all promotion and rollback operations
type PromotionAudit {
  id: ID!
  jobId: ID!
  actor: String!
  action: String!
  beforeJson: JSON
  afterJson: JSON
  timestamp: DateTime!
  
  # Relationships
  job: ExtractionJob!
}

# ParserRegistry configures which parsers are enabled for different file types
type ParserRegistry {
  id: ID!
  orgId: ID!
  slot: String!
  mimeType: String
  extension: String
  parserName: String!
  parserVersion: String!
  minConfidence: Float!
  featureFlag: Boolean!
  enabled: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

# ===== CROSS-LAYER ONTOLOGY ENTITIES =====

# Content entities (generic content type)
type Content {
  id: ID!
  type: String!
  properties: JSON!
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
}

# Scene entity (Idea layer)
type Scene {
  id: ID!
  org_id: String!
  project_id: String!
  number: String!
  title: String!
  location: String
  time_of_day: String
  page_count: Float
  status: String!
  description: String
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Cross-layer relationships
  scheduledOn: ShootDay # Scene -> ShootDay (Idea to IRL)
  hasLocation: Location # Scene -> Location
  budgetedBy: [Budget!]! # Scene -> Budget (Idea to Ops)
  purchaseOrders: [PurchaseOrder!]! # Scene -> PurchaseOrder (Idea to Ops)
  characters: [Character!]! # Scene -> Character
}

# Character entity (Idea layer)
type Character {
  id: ID!
  org_id: String!
  project_id: String!
  name: String!
  role_type: String!
  description: String
  age_range: String
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Cross-layer relationships
  portrayedBy: Talent # Character -> Talent (Idea to IRL)
  scenes: [Scene!]! # Character -> Scene
  castingStatus: String # uncast, cast, callback, etc.
}

# Talent entity (IRL layer)
type Talent {
  id: ID!
  org_id: String!
  name: String!
  agent_contact: String
  union_status: String
  rate_amount: Float
  status: String!
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Cross-layer relationships
  characters: [Character!]! # Talent -> Character (IRL to Idea)
  shootDays: [ShootDay!]! # Talent -> ShootDay
  purchaseOrders: [PurchaseOrder!]! # Talent -> PurchaseOrder (IRL to Ops)
}

# Crew entity (IRL layer)
type Crew {
  id: ID!
  org_id: String!
  name: String!
  role: String!
  department: String!
  rate_amount: Float
  status: String!
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Cross-layer relationships
  shootDays: [ShootDay!]! # Crew -> ShootDay
  purchaseOrders: [PurchaseOrder!]! # Crew -> PurchaseOrder (IRL to Ops)
}

# ShootDay entity (IRL layer)
type ShootDay {
  id: ID!
  org_id: String!
  project_id: String!
  date: DateTime!
  call_time: String
  wrap_time: String
  location_id: String
  status: String!
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Cross-layer relationships
  scenes: [Scene!]! # ShootDay -> Scene (IRL to Idea)
  talent: [Talent!]! # ShootDay -> Talent
  crew: [Crew!]! # ShootDay -> Crew
  location: Location # ShootDay -> Location
}

# Location entity (IRL layer)
type Location {
  id: ID!
  org_id: String!
  name: String!
  address: String
  type: String!
  capacity: Int
  rate_amount: Float
  status: String!
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Cross-layer relationships
  scenes: [Scene!]! # Location -> Scene (IRL to Idea)
  shootDays: [ShootDay!]! # Location -> ShootDay
}

# Budget entity (Ops layer)
type Budget {
  id: ID!
  org_id: String!
  project_id: String!
  category: String!
  line_item: String!
  budgeted_amount: Float!
  actual_amount: Float
  status: String!
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Cross-layer relationships
  scenes: [Scene!]! # Budget -> Scene (Ops to Idea)
  purchaseOrders: [PurchaseOrder!]! # Budget -> PurchaseOrder
}

# PurchaseOrder entity (Ops layer)
type PurchaseOrder {
  id: ID!
  org_id: String!
  project_id: String!
  vendor: String!
  amount: Float!
  status: String!
  description: String
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Cross-layer relationships
  scenes: [Scene!]! # PurchaseOrder -> Scene (Ops to Idea)
  talent: [Talent!]! # PurchaseOrder -> Talent (Ops to IRL)
  crew: [Crew!]! # PurchaseOrder -> Crew (Ops to IRL)
  budget: Budget # PurchaseOrder -> Budget
}

# Organization entity (updated with cluster support)
type Organization {
  id: ID!
  name: String!
  slug: String!
  settings: JSON
  projects: [Project!]!
  sources: [Source!]!
  users: [User!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

# Project entity (updated with cluster support)
type Project {
  id: ID!
  orgId: ID!
  name: String!
  status: ProjectStatus!
  settings: JSON
  metadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
  
  # Cluster-centric relationships
  contentClusters: [ContentCluster!]!
  scenes: [Scene!]!
  characters: [Character!]!
  shootDays: [ShootDay!]!
  budgets: [Budget!]!
}

# User entity
type User {
  id: ID!
  orgId: ID!
  email: String!
  name: String!
  role: String!
  permissions: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

# ===== EXTENDED QUERIES AND MUTATIONS =====

extend type Query {
  # Cluster-centric queries
  getContentCluster(clusterId: ID!, orgId: ID!): ContentCluster
  getContentClusters(orgId: ID!, fileId: ID, projectId: ID): [ContentCluster!]!
  getExtractionJob(jobId: ID!, orgId: ID!): ExtractionJob
  getExtractionJobs(orgId: ID!, status: String): [ExtractionJob!]!
  
  # Cross-layer entity queries
  getScenes(orgId: ID!, projectId: ID): [Scene!]!
  getCharacters(orgId: ID!, projectId: ID): [Character!]!
  getTalent(orgId: ID!): [Talent!]!
  getCrew(orgId: ID!): [Crew!]!
  getShootDays(orgId: ID!, projectId: ID): [ShootDay!]!
  getLocations(orgId: ID!): [Location!]!
  getBudgets(orgId: ID!, projectId: ID): [Budget!]!
  getPurchaseOrders(orgId: ID!, projectId: ID): [PurchaseOrder!]!
  
  # Cross-layer validation queries
  validateCrossLayerLinks(orgId: ID!): JSON!
  getCrossLayerStatistics(orgId: ID!): JSON!
}

extend type Mutation {
  # Cluster processing mutations
  triggerClusterExtraction(fileId: ID!, orgId: ID!, parserName: String): ExtractionJob!
  promoteExtractionJob(jobId: ID!, orgId: ID!): Boolean!
  rollbackExtractionJob(jobId: ID!, orgId: ID!): Boolean!
  
  # Cross-layer link mutations
  createCrossLayerLink(orgId: ID!, fromEntityId: ID!, toEntityId: ID!, relationshipType: String!): Boolean!
  validateAndRepairLinks(orgId: ID!): JSON!
}

type LinkResult { success: Boolean! }

extend type Mutation {
  linkSceneToCharacter(sceneId: ID!, characterId: ID!, orgId: ID!, userId: String!): LinkResult!
}
