# Global & Cross-Cutting UI Components

* [ ] **Global & Cross-Cutting UI Components:** These features are available throughout the application, ensuring a consistent and accessible user experience.

  * [ ] **Command Palette (Quick Actions):** A global quick-launch dialog accessible via keyboard shortcut (e.g. **⌘+K** or **Ctrl+K**). When opened, it allows the user to fuzzy-search for navigation targets (pages, projects) as well as common actions (e.g. "Go to File Explorer", "New Call Sheet", "Invite User", or even specific commands like "Run Project Audit"). Selecting a result executes that action or navigates accordingly. Ensure the palette is context-aware where useful (for instance, if on a project page, palette could list project-specific commands first). This improves efficiency for power users.
  * [ ] **Keyboard Navigation & Shortcuts:** All interactive elements and dialogs should be reachable and operable via keyboard alone. This includes tabbing through links/buttons in a logical order, using **Enter/Space** to activate, **Esc** to close modals, arrow keys for menu navigation, etc. Important shortcuts: e.g. pressing "/" might focus the search bar, "?" to open a keyboard shortcuts help, or specific ones like **Ctrl+P** for command palette if not using the common one. Provide documentation of available shortcuts (maybe a cheat sheet in Settings or via the "?" key).
  * [ ] **Right-Pane Inspector:** A consistent side panel that appears to show details of selected items (as noted in File Explorer, Mapping Studio, etc.). This panel should have a common design and be reuseable for various entities: file details, crew contact info, commit/log entry details, etc. It usually includes actions (like "Open file", "Approve suggestion" if it's showing a suggestion detail, or "Edit crew info"). The inspector can often be opened by selecting an item or clicking a "Details" button and closed by a close \[x] or clicking off. It should be keyboard-focus trapped when open (for accessibility), and not scroll the underlying page when active.
  * [ ] **Toasts & Feedback Messages:** Use toast notifications to confirm user actions and show ephemeral messages. For example, "✅ Project created successfully" or "⚠️ Failed to rename file (network error)." These toasts should appear at a consistent location (e.g. bottom-right) and auto-dismiss after a few seconds (for success/info), while error toasts might stay until clicked. Provide distinct styling for success (green), error (red), warning (orange), info (blue) for quick recognition. The content should be concise. If an action has a more detailed outcome, consider the toast having a link (e.g. "View details" to go to a log or relevant page). Ensure toasts do not overlap critical UI elements and are responsive on smaller screens (move or resize appropriately).
  * [ ] **Real-Time Updates:** Across the app, reflect changes as they happen without requiring full page reloads. Leverage the backend's real-time features (Supabase subscriptions or Orchestrator push) to update UI state:

    * [ ] New files or file changes: If a file is added/removed externally, the File Explorer should show it (and Mapping Studio should update if it was an expected file, etc.).
    * [ ] Suggestions/approvals: When an agent creates a new suggestion, it should appear in the Approvals queue and possibly as an alert. When any suggestion gets approved/rejected, all views (File Explorer, mapping list, etc.) reflecting that file's status should update (e.g. the flag on the file disappears upon approval of rename).
    * [ ] AI chat responses: stream tokens as they arrive for a natural feel.
    * [ ] Call sheet status: once generated by the agent, the UI receives the event and can notify the user immediately (even if they navigated away from Composer view).
    * [ ] Use web sockets or Supabase's real-time channels to implement this where possible, and test that even with multiple users, everyone's view stays consistent.
  * [ ] **Pagination & Virtual Scrolling:** For any lists that can grow long (files, log entries, notifications, crew list, etc.), use a performant approach to display items. Paginate or lazy-load items in chunks, and/or use virtual scrolling so the UI remains snappy. Provide UI controls to load more or paginate (with page numbers or "Load more" buttons/infinite scroll). Also, remember the user's position if they navigate away and back (especially for log or file lists).
  * [ ] **Loading States & Error States:** Ensure every view and component has a defined loading state (e.g. skeleton rows or spinners when data is fetching) and a clear error state/message if data fails to load. For example, if the File Explorer data fails to load, show a message like "Unable to load files. Check your connection or try again." with a retry button. Avoid blank screens. Use disabled states on buttons while actions are in progress (to prevent double submissions). For long-running processes, consider intermediate feedback (like a progress bar or status updates as mentioned).
  * [ ] **Responsive Design:** The UI should gracefully adapt to different screen sizes. While this is a desktop/web app for producers, it might be used on a tablet or smaller laptop. Ensure layouts are fluid or have breakpoints – side panels might collapse on narrow screens, tables might scroll, menus might turn into dropdowns, etc. Test key views like File Explorer and Cockpit on various resolutions.
  * [ ] **Consistency & Theming:** Use a coherent design system across all components (colors, typography, buttons, inputs). If a design system is defined (as per design docs or CSS), adhere to it so that, for example, all modals look alike, all form controls have consistent styles and validation messages, etc. Support both light and dark mode if required (or at least ensure the color scheme is accessible).
  * [ ] **Accessibility Compliance:** Beyond keyboard, ensure sufficient color contrast for text and icons, provide aria-labels or tooltips for icons/buttons (especially if just an icon button like edit/trash), and use semantic HTML where possible for screen readers. For any dynamic content (like real-time updates), ensure it's announced to assistive tech if appropriate (or at least doesn't interfere). Test critical workflows with a screen reader to catch any glaring issues.

Each item above should be verified during implementation to ensure the frontend meets the specified behavior and aligns with the backend architecture (e.g. using provided APIs for sync, approvals, ledger, etc.) and that all edge cases (error conditions, empty states, multi-user scenarios) are handled gracefully. This checklist will serve as the acceptance criteria during UI QA at engineering kickoff, covering MVP functionality and Phase-2 enhancements.
